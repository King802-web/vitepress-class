<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>计算机组成原理图片生成器</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      text-align: center;
      color: #0066cc;
    }
    
    .image-generator {
      margin-bottom: 30px;
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 6px;
    }
    
    canvas {
      display: block;
      margin: 0 auto;
      border: 1px solid #ddd;
    }
    
    .controls {
      margin-top: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    
    button {
      padding: 8px 16px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    button:hover {
      background: #0055aa;
    }
    
    p {
      text-align: center;
      margin-top: 10px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>计算机组成原理图片生成器</h1>
    
    <div class="image-generator">
      <h2>冯·诺依曼架构图 (800x600)</h2>
      <canvas id="vonNeumannCanvas" width="800" height="600"></canvas>
      <div class="controls">
        <button onclick="generateVonNeumann()">生成架构图</button>
        <button onclick="downloadCanvas('vonNeumannCanvas', 'von-neumann-architecture.png')">下载图片</button>
      </div>
      <p>点击按钮生成冯·诺依曼架构图，然后下载并保存到public/images目录</p>
    </div>
    
    <div class="image-generator">
      <h2>计算机发展历程图 (1000x600)</h2>
      <canvas id="historyCanvas" width="1000" height="600"></canvas>
      <div class="controls">
        <button onclick="generateComputerHistory()">生成历程图</button>
        <button onclick="downloadCanvas('historyCanvas', 'computer-history.png')">下载图片</button>
      </div>
      <p>点击按钮生成计算机发展历程图，然后下载并保存到public/images目录</p>
    </div>

    <div class="image-generator">
      <h2>计算机系统层次结构图 (800x600)</h2>
      <canvas id="hierarchyCanvas" width="800" height="600"></canvas>
      <div class="controls">
        <button onclick="generateSystemHierarchy()">生成层次结构图</button>
        <button onclick="downloadCanvas('hierarchyCanvas', 'computer-hierarchy.png')">下载图片</button>
      </div>
      <p>点击按钮生成计算机系统层次结构图，然后下载并保存到public/images目录</p>
    </div>
  </div>

  <script>
    // 冯·诺依曼架构图生成函数
    function generateVonNeumann() {
      const canvas = document.getElementById('vonNeumannCanvas');
      const ctx = canvas.getContext('2d');
      
      // 清空画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 设置背景色
      ctx.fillStyle = '#f0f8ff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // 绘制标题
      ctx.fillStyle = '#003366';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('冯·诺依曼架构', canvas.width/2, 50);
      
      // 绘制中央处理单元框
      drawComponent(ctx, canvas.width/2, 180, 300, 100, '#4682b4', '中央处理单元 (CPU)');
      
      // 绘制控制器和运算器
      drawComponent(ctx, canvas.width/2 - 80, 180, 140, 60, '#6495ed', '控制器');
      drawComponent(ctx, canvas.width/2 + 80, 180, 140, 60, '#6495ed', '运算器');
      
      // 绘制存储器
      drawComponent(ctx, canvas.width/2, 320, 300, 80, '#20b2aa', '存储器');
      
      // 绘制输入设备
      drawComponent(ctx, canvas.width/2 - 200, 450, 140, 80, '#3cb371', '输入设备');
      
      // 绘制输出设备
      drawComponent(ctx, canvas.width/2 + 200, 450, 140, 80, '#ff7f50', '输出设备');
      
      // 绘制连接线
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 3;
      
      // CPU到存储器的连接
      drawArrow(ctx, canvas.width/2, 230, canvas.width/2, 280);
      
      // 存储器到输入/输出设备的连接
      drawArrow(ctx, canvas.width/2, 360, canvas.width/2, 400);
      drawArrow(ctx, canvas.width/2, 400, canvas.width/2 - 200, 450);
      drawArrow(ctx, canvas.width/2, 400, canvas.width/2 + 200, 450);
      
      // 添加说明文字
      ctx.fillStyle = '#333';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('指令和数据总线', canvas.width/2 + 80, 260);
      ctx.fillText('输入/输出总线', canvas.width/2 + 80, 380);
      
      // 添加注释
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText('特点：', 50, 520);
      ctx.fillText('1. 存储程序概念：指令和数据存储在同一存储器中', 70, 540);
      ctx.fillText('2. 顺序执行指令：按照存储顺序依次取出并执行指令', 70, 560);
      ctx.fillText('3. 五大基本部件：运算器、控制器、存储器、输入设备、输出设备', 70, 580);
    }
    
    // 计算机发展历程图生成函数
    function generateComputerHistory() {
      const canvas = document.getElementById('historyCanvas');
      const ctx = canvas.getContext('2d');
      
      // 清空画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 设置背景色
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, '#f0f8ff');
      gradient.addColorStop(1, '#e6e6fa');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // 绘制标题
      ctx.fillStyle = '#003366';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('计算机发展历程', canvas.width/2, 50);
      
      // 绘制时间轴
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(100, 300);
      ctx.lineTo(900, 300);
      ctx.stroke();
      
      // 绘制时间节点
      const timePoints = [
        { year: '1946', label: '第一代', desc: 'ENIAC', color: '#4682b4', x: 150 },
        { year: '1958', label: '第二代', desc: '晶体管计算机', color: '#20b2aa', x: 300 },
        { year: '1965', label: '第三代', desc: '集成电路', color: '#3cb371', x: 450 },
        { year: '1972', label: '第四代', desc: '微处理器', color: '#ff7f50', x: 600 },
        { year: '现在', label: '第五代', desc: 'AI与量子计算', color: '#9370db', x: 750 }
      ];
      
      timePoints.forEach(point => {
        // 绘制时间节点圆圈
        ctx.fillStyle = point.color;
        ctx.beginPath();
        ctx.arc(point.x, 300, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // 绘制年份
        ctx.fillStyle = '#333';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(point.year, point.x, 330);
        
        // 绘制上方标签
        ctx.fillStyle = point.color;
        ctx.font = 'bold 18px Arial';
        ctx.fillText(point.label, point.x, 270);
        
        // 绘制下方描述
        ctx.fillStyle = '#333';
        ctx.font = '16px Arial';
        ctx.fillText(point.desc, point.x, 360);
        
        // 为部分节点添加图标
        if (point.year === '1946') {
          drawSimpleIcon(ctx, point.x, 220, 'vacuum-tube');
        } else if (point.year === '1958') {
          drawSimpleIcon(ctx, point.x, 220, 'transistor');
        } else if (point.year === '1972') {
          drawSimpleIcon(ctx, point.x, 220, 'chip');
        } else if (point.year === '现在') {
          drawSimpleIcon(ctx, point.x, 220, 'quantum');
        }
      });
      
      // 添加摩尔定律标注
      ctx.fillStyle = 'rgba(255, 99, 71, 0.2)';
      ctx.beginPath();
      ctx.moveTo(450, 400);
      ctx.lineTo(900, 150);
      ctx.lineTo(900, 400);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = '#ff6347';
      ctx.font = 'italic 16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('摩尔定律: 芯片上的晶体管数量每18-24个月翻一番', 700, 180);
      
      // 添加注释
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText('计算机发展的关键特征：', 100, 450);
      ctx.fillText('- 体积：从房间大小缩小到掌上设备', 120, 470);
      ctx.fillText('- 性能：计算能力呈指数级增长', 120, 490);
      ctx.fillText('- 成本：价格持续下降，普及率提高', 120, 510);
      ctx.fillText('- 应用：从专业计算到无处不在的智能设备', 120, 530);
    }
    
    // 计算机系统层次结构图生成函数
    function generateSystemHierarchy() {
      const canvas = document.getElementById('hierarchyCanvas');
      const ctx = canvas.getContext('2d');
      
      // 清空画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 设置背景色
      ctx.fillStyle = '#f9f9f9';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // 绘制标题
      ctx.fillStyle = '#003366';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('计算机系统层次结构', canvas.width/2, 50);
      
      // 定义层次结构
      const levels = [
        { label: '应用软件层', color: '#9370db', examples: '文字处理器、浏览器、游戏' },
        { label: '高级语言层', color: '#6a5acd', examples: 'Python、Java、C++' },
        { label: '操作系统层', color: '#4682b4', examples: 'Windows、Linux、macOS' },
        { label: '指令集架构层', color: '#20b2aa', examples: 'x86、ARM、RISC-V' },
        { label: '微架构层', color: '#3cb371', examples: '流水线、缓存、分支预测' },
        { label: '逻辑电路层', color: '#ff7f50', examples: '加法器、寄存器、多路复用器' },
        { label: '晶体管层', color: '#ff6347', examples: 'CMOS晶体管、逻辑门' }
      ];
      
      // 绘制金字塔
      const pyramidWidth = 600;
      const pyramidHeight = 400;
      const pyramidTop = 100;
      const levelHeight = pyramidHeight / levels.length;
      
      levels.forEach((level, index) => {
        // 计算当前层的宽度（金字塔从上到下变宽）
        const widthRatio = 0.3 + 0.7 * (index / (levels.length - 1));
        const currentWidth = pyramidWidth * widthRatio;
        const x = (canvas.width - currentWidth) / 2;
        const y = pyramidTop + index * levelHeight;
        
        // 绘制层次矩形
        ctx.fillStyle = level.color;
        ctx.fillRect(x, y, currentWidth, levelHeight);
        
        // 绘制边框
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, currentWidth, levelHeight);
        
        // 绘制层次标签
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(level.label, canvas.width/2, y + levelHeight/2);
        
        // 绘制示例
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(level.examples, x + 10, y + levelHeight - 10);
      });
      
      // 添加抽象度和实现细节标注
      ctx.fillStyle = '#333';
      ctx.font = 'italic 16px Arial';
      ctx.textAlign = 'right';
      ctx.fillText('抽象度增加', 150, 150);
      ctx.textAlign = 'left';
      ctx.fillText('实现细节增加', canvas.width - 150, 450);
      
      // 添加箭头
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      drawArrow(ctx, 150, 170, 150, 300);
      drawArrow(ctx, canvas.width - 150, 430, canvas.width - 150, 300);
      
      // 添加注释
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('每一层都为上一层提供服务，同时隐藏实现细节', canvas.width/2, 550);
      ctx.fillText('不同层次可以独立发展，只要接口保持兼容', canvas.width/2, 570);
    }
    
    // 辅助函数：绘制组件
    function drawComponent(ctx, x, y, width, height, color, label) {
      // 绘制矩形
      ctx.fillStyle = color;
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      
      // 绘制圆角矩形
      const radius = 10;
      ctx.beginPath();
      ctx.moveTo(x - width/2 + radius, y - height/2);
      ctx.lineTo(x + width/2 - radius, y - height/2);
      ctx.arcTo(x + width/2, y - height/2, x + width/2, y - height/2 + radius, radius);
      ctx.lineTo(x + width/2, y + height/2 - radius);
      ctx.arcTo(x + width/2, y + height/2, x + width/2 - radius, y + height/2, radius);
      ctx.lineTo(x - width/2 + radius, y + height/2);
      ctx.arcTo(x - width/2, y + height/2, x - width/2, y + height/2 - radius, radius);
      ctx.lineTo(x - width/2, y - height/2 + radius);
      ctx.arcTo(x - width/2, y - height/2, x - width/2 + radius, y - height/2, radius);
      ctx.closePath();
      
      ctx.fill();
      ctx.stroke();
      
      // 绘制标签
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, x, y);
    }
    
    // 辅助函数：绘制箭头
    function drawArrow(ctx, fromX, fromY, toX, toY) {
      const headLength = 15;
      const angle = Math.atan2(toY - fromY, toX - fromX);
      
      // 绘制线条
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();
      
      // 绘制箭头头部
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), toY - headLength * Math.sin(angle - Math.PI/6));
      ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), toY - headLength * Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = ctx.strokeStyle;
      ctx.fill();
    }
    
    // 辅助函数：绘制简单图标
    function drawSimpleIcon(ctx, x, y, type) {
      ctx.fillStyle = '#333';
      
      switch(type) {
        case 'vacuum-tube':
          // 绘制真空管图标
          ctx.beginPath();
          ctx.moveTo(x - 10, y + 20);
          ctx.lineTo(x - 10, y - 20);
          ctx.lineTo(x + 10, y - 10);
          ctx.lineTo(x + 10, y + 10);
          ctx.closePath();
          ctx.fill();
          break;
        case 'transistor':
          // 绘制晶体管图标
          ctx.beginPath();
          ctx.moveTo(x - 15, y - 15);
          ctx.lineTo(x - 15, y + 15);
          ctx.moveTo(x - 15, y);
          ctx.lineTo(x + 15, y - 15);
          ctx.lineTo(x + 15, y + 15);
          ctx.stroke();
          break;
        case 'chip':
          // 绘制芯片图标
          ctx.fillRect(x - 15, y - 15, 30, 30);
          ctx.strokeStyle = '#fff';
          ctx.beginPath();
          ctx.moveTo(x - 15, y - 5);
          ctx.lineTo(x - 5, y - 5);
          ctx.lineTo(x - 5, y - 15);
          ctx.moveTo(x + 5, y - 15);
          ctx.lineTo(x + 5, y - 5);
          ctx.lineTo(x + 15, y - 5);
          ctx.moveTo(x + 15, y + 5);
          ctx.lineTo(x + 5, y + 5);
          ctx.lineTo(x + 5, y + 15);
          ctx.moveTo(x - 5, y + 15);
          ctx.lineTo(x - 5, y + 5);
          ctx.lineTo(x - 15, y + 5);
          ctx.stroke();
          break;
        case 'quantum':
          // 绘制量子计算图标
          ctx.beginPath();
          ctx.arc(x, y, 15, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.ellipse(x, y, 15, 5, Math.PI/4, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.ellipse(x, y, 15, 5, Math.PI*3/4, 0, Math.PI * 2);
          ctx.stroke();
          break;
      }
    }
    
    // 下载Canvas为图片
    function downloadCanvas(canvasId, filename) {
      const canvas = document.getElementById(canvasId);
      const link = document.createElement('a');
      link.download = filename;
      link.href = canvas.toDataURL('image/png', 0.8);
      link.click();
    }
    
    // 页面加载后初始化显示
    window.onload = function() {
      generateVonNeumann();
      generateComputerHistory();
      generateSystemHierarchy();
    };
  </script>
</body>
</html> 